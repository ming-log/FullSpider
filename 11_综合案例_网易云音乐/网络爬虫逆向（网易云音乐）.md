---
title: 网络爬虫逆向（网易云音乐）
date: 2023-05-09 16:40:34
tags:
 - 网络爬虫逆向
 - python
categories:
 - 技术
mathjax: true
---

# 抓取目标

目标网址：https://music.163.com/#/song?id=2045090557

抓取目标：音乐下载抓取

![image-20230509164245060](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509164245060.png)

<!-- more -->

# 网页分析

打开开发者工具，点击播放按钮，生成播放音乐数据包。

![image-20230509164521309](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509164521309.png)

通过观察数据包可以知道，包含音乐链接的数据包为`v1?csrf_token=`

![image-20230509164802245](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509164802245.png)

为了验证该地址为音乐地址，可以将其复制到浏览器中打开。

![image-20230509164850114](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509164850114.png)

可以成功播放。

接下来只需搞清楚，如何可以正确的请求到该数据包即可。

点击该数据包的标头，可以看到数据包：

请求地址为`https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=`

请求方式为`POST`请求。

![image-20230509164934674](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509164934674.png)

点击载荷查看`POST`请求的表单。

![image-20230509165041077](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509165041077.png)

可以看到表单数据为一堆数字和英文的组合，说明表单参数被加密了。

接下来就需要去研究表单是如何进行加密的。

点击启动器，依次研究每个调用堆栈，查看数据包是从哪个步骤开始加密的。

![image-20230509165531446](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509165531446.png)

这里就需要慢慢找，数据包比较多。

点击第一个调用点，进入到源码。打赏断点后，重新点击播放按钮，让代码暂停到断点处。

![image-20230509165646112](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509165646112.png)

从断点位置可以看出，到当前位置参数已经被加密了，接下来就需要往前找。点击右下角的调用堆栈，往前找一个。可以发现在此处同样是被加密状态。

![image-20230509170056200](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509170056200.png)

按照该方式继续往前找。

中间步骤比较简单，就是找前一个调用参数有没有被加密，在此就不再赘述。

一直到下图所示数据包位置开始详细分析。

![image-20230509170233040](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509170233040.png)

往前找`e2x`的被赋值位置，在其前方打上断点。

![image-20230509170340005](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509170340005.png)

重新点击播放按钮。此时注意请求的`url`地址

我们`POST`请求发送的地址为`https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=`

第一次断点出的地址不正确，释放此次断点，直到地址正确（或者大致差不多）。

![image-20230509170716968](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509170716968.png)

连续点击释放断点，直到出现以下内容。此时的`url`与我们`POST`请求的`url`稍微有一点出入，这个后面会讲到是怎么还原的。

![image-20230509170758601](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509170758601.png)

接下来开始单步调试。

首先查看一下此时`e2x`的内容。

![image-20230509170907864](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509170907864.png)

发现这个时候参数内容是未加密的状态。我们进行单步调试，看看哪一步是将参数进行加密的。

一直调试的下图所示位置，我们发现在变量`bMs8k`中出现了加密后的数据。

![image-20230509171224941](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509171224941.png)

通过对源码的观察我们不难发现`bMs8k`是通过`window.asrsea()`对`i2x`进行加密的。

将其这部分代码复制出来。

```js
var bMs8k = window.asrsea(JSON.stringify(i2x), bsi5n(["流泪", "强"]), bsi5n(Vx0x.md), bsi5n(["爱心", "女孩", "惊恐", "大笑"]));
```

函数`window.asrsea`传入了4个参数：

- `JSON.stringify(i2x)`：用于将`i2x`转化为`JSON`格式。

- `bsi5n(["流泪", "强"])`：通过在`console`中对其进行打印发现为固定参数，`'010001'`

  ![image-20230509171629282](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509171629282.png)

- `bsi5n(Vx0x.md)`：通过在`console`中对其进行打印发现也为固定参数，`'00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7'`

![image-20230509171740398](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509171740398.png)

- `bsi5n(["爱心", "女孩", "惊恐", "大笑"])`：通过在`console`中对其进行打印发现同样是固定参数，`'0CoJUm6Qyw8W8jud'`

![image-20230509171835814](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509171835814.png)

接下来对函数`window.asrsea`进行详细分析。

点击进入函数，将其内容复制出来。

![image-20230509172115203](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509172115203.png)

![image-20230509172139364](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509172139364.png)

复制代码如下：

```js
function d(d, e, f, g) {
    var h = {}
    , i = a(16);
    return h.encText = b(d, g),
    h.encText = b(h.encText, i),
    h.encSecKey = c(i, e, f),
    h
}
```

按照`JS`语法规则对其进行改写成如下格式。

```js
function d(d, e, f, g) {
    var h = {}
    var i = a(16);
    h.encText = b(d, g);
    h.encText = b(h.encText, i);
    h.encSecKey = c(i, e, f);
    return h
}
```

经过前面的分析，在该函数中参数`e`、`f`、`g`为固定值，`d`为待加密参数的`JSON`格式。

还有很多变量是未知的，我们需要依次对其进行解决。

首先是`a`，将其代码复制出来如下所示。

```js
function a(a) {
    var d, e, b = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", c = "";
    for (d = 0; a > d; d += 1)
        e = Math.random() * b.length,
            e = Math.floor(e),
            c += b.charAt(e);
    return c
}
```

> `a`函数比较简单，作用是生成16位的随机字符串，字符在a-z0-9中取值。

接下来看`b`，同样需要将其代码复制出来。

```js
function b(a, b) {
    var c = CryptoJS.enc.Utf8.parse(b)
    , d = CryptoJS.enc.Utf8.parse("0102030405060708")
    , e = CryptoJS.enc.Utf8.parse(a)
    , f = CryptoJS.AES.encrypt(e, c, {
    iv: d,
    mode: CryptoJS.mode.CBC
    });
    return f.toString()
}
```

> `b`函数的作用就是做一次`AES`加密，`key`为`b`，`iv`为`b'0102030405060708'`，`mode`是`CBC`格式。

接下来看`c`。

```js
function c(a, b, c) {
    var d, e;
    return setMaxDigits(131),
    d = new RSAKeyPair(b,"",c),
    e = encryptedString(d, a)
}
```

> `c`函数的功能是对传入的参数`a`做`RSA`加密，公钥为`d`。调用的`RSA`加密是自己写的`encryptedString`函数（这个在后面扩展内容中会对其进行验证），如果要进一步去读他这个自己写的`RSA`加密函数，难度会很大。
>
> 有一个简单方法，从外部调用来看该函数的作用就是将前面生成的随机`16`位字符串进行了`RSA`加密，由于使用前面随机生成的`16`位字符串都可以达到对整个请求的正常访问，那么我们可以在这里直接将这个随机字符串固定下来肯定也是没问题的，后续调用`RSA`加密该参数时，直接也将加密的结果也复制出来，这样就可以大大简化我们的工作量。

直接在`console`打印出这两个参数，如下所示：

![image-20230509174427523](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509174427523.png)

```js
a: '1eOHSUBwXoWq3xIQ'
encryptedString(d, a): '5275ed9a42b5a4c3a056bda80986295e57d4c0afebbc5edd76d21ef6a74e9cc9c4644eefc182c2a19fc8ade0307fda204254285100c47b0ad2339e3d0c633402ba037f90f5b90c0794f887d7393706150d5d0999f9b715d7b4e9a5c19613ef5c18d68414d84f7f4ed16a179d9d6243ffaddf3c9012e14b61d615f3f32d7e554b'
```

现在所有的位置变量我们都已经解决，将`window.asrsea`函数进一步改写为如下所示格式：

```js
function d(d, 
            e='010001', 			f='00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7', 
            g='0CoJUm6Qyw8W8jud') {
    var h = {}
    var i = '1eOHSUBwXoWq3xIQ';  // 随机数被我们固定下来
    h.encText = b(d, g);  // 对d进行AES加密，key为g，密钥为'0102030405060708'
    h.encText = b(h.encText, i);  // 对h.encText进行AES加密，key为i，密钥为'0102030405060708'
    h.encSecKey = '5275ed9a42b5a4c3a056bda80986295e57d4c0afebbc5edd76d21ef6a74e9cc9c4644eefc182c2a19fc8ade0307fda204254285100c47b0ad2339e3d0c633402ba037f90f5b90c0794f887d7393706150d5d0999f9b715d7b4e9a5c19613ef5c18d68414d84f7f4ed16a179d9d6243ffaddf3c9012e14b61d615f3f32d7e554b';
    return h
}
```

# 代码实现

整个加密函数的逻辑已经被我们捋清楚，接下来使用`Python`对其功能进行实现。

![image-20230509180823133](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509180823133.png)

成功生成对应加密参数。

![image-20230509180839184](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509180839184.png)

接下来使用该参数对`https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=`进行请求。

![image-20230509181704362](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509181704362.png)

请求成功，获取到对应的音乐下载地址。

![image-20230509181723167](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509181723167.png)

访问音乐地址，将其下载到本地。

![image-20230509183212202](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509183212202.png)

下载成功，并且可以成功播放。

![image-20230509183246108](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509183246108.png)

到现在为止，音乐已经被我们下载完毕。并且支持批量下载，只需在参数`'ids'`中加入对应的歌曲编号即可。

例如修改为：`[2045090557, 1857630559]`，即可下载两个音乐。

![image-20230509183555529](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509183555529.png)

![image-20230509183550209](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509183550209.png)

都下载成功！

![image-20230509183643678](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509183643678.png)

但是现在还不太完美，我们只能够使用音乐的编号对音乐文件进行命名，并不知道歌曲名称和歌手名字。

解决这个问题的方式和前面完全一样，就不再赘述。

但是有一点需要注意，其参数格式不和之前一样，如下图所示。

![image-20230509184239652](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509184239652.png)

定义一个函数用于根据音乐`id`获取对应歌曲名称和歌手名字。

![image-20230509190123783](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509190123783.png)

![image-20230509190131696](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509190131696.png)

完整代码如下：

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import json
import requests
import base64

def b(a, b):
    c = b.encode('utf-8')
    d = '0102030405060708'.encode('utf-8')
    e = a.encode('utf-8')

    aes = AES.new(key=c, mode=AES.MODE_CBC, iv=d)
    e = pad(e, 16)
    return base64.b64encode(aes.encrypt(e)).decode()

def d(d,
      e='010001',
      f='00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7',
      g='0CoJUm6Qyw8W8jud'):
    h = {}
    i = '1eOHSUBwXoWq3xIQ'
    h['encText'] = b(d, g)
    h['encText'] = b(h['encText'], i)
    h['encSecKey'] = '5275ed9a42b5a4c3a056bda80986295e57d4c0afebbc5edd76d21ef6a74e9cc9c4644eefc182c2a19fc8ade0307fda204254285100c47b0ad2339e3d0c633402ba037f90f5b90c0794f887d7393706150d5d0999f9b715d7b4e9a5c19613ef5c18d68414d84f7f4ed16a179d9d6243ffaddf3c9012e14b61d615f3f32d7e554b'
    return h

def get_name(id):
    music_detial_api = 'https://music.163.com/weapi/v3/song/detail?csrf_token='

    unenc_data = {"id": str(id),
                  "c": '[{"id": "%s"}]' % str(id),
                  "csrf_token": ""}
    enc_data = d(json.dumps(unenc_data))

    data = {
            'params': enc_data['encText'],
            'encSecKey': enc_data['encSecKey']
        }

    # 定义请求头
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36",
    }
    resp = requests.post(music_detial_api, headers=headers, data=data).json()
    song_name = resp['songs'][0]['name']
    author_name = ','.join([i['name'] for i in resp['songs'][0]['ar']])
    return song_name + f'({author_name}).m4a'

def main(songs_list):
    # 定义请求api
    music163_api = 'https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token='
    # 定义未加密参数
    unenc_data = {"ids": songs_list,
            "level": "standard",
            "encodeType": "aac",
            "csrf_token": ""}


    # 进行参数加密
    enc_data = d(json.dumps(unenc_data))
    # 定义表单
    data = {
        'params': enc_data['encText'],
        'encSecKey': enc_data['encSecKey']
    }
    # 定义请求头
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36",
    }
    resp = requests.post(music163_api, headers=headers, data=data).json()
    for i in range(len(resp["data"])):
        filename = get_name(resp["data"][i]["id"])
        with open(filename, 'wb') as f:
            f.write(requests.get(resp["data"][i]["url"]).content)
        print(filename + '下载成功！')


if __name__ == '__main__':
    songs_list = [2045090557, 1857630559]
    main(songs_list)

```

将`songs_list`中更换为其他音乐的`id`即可完成批量下载到本地，如下图所示。

![image-20230509190428523](https://ming-log.oss-cn-hangzhou.aliyuncs.com/img/image-20230509190428523.png)

# 拓展

## 验证普通RSA加密是否和网页加密结果一致









## RSA加密基本原理







## 该案例中RSA加密分析









## Python代码实现



































